{"version":3,"sources":["../src/resolveStringLiteral.js"],"names":["path","styleModuleImportMap","styleNameAttribute","options","classNameAttribute","node","openingElement","attributes","find","attribute","name","resolvedStyleName","value","expression","Error","splice","indexOf"],"mappings":";;;;;;AAEA;;AAMA;;;;AACA;;;;;;AAUA;;;kBAGe,CAACA,IAAD,EAAUC,oBAAV,EAA0DC,kBAA1D,EAA4FC,OAA5F,KAA2H;AACxI,QAAMC,qBAAqBJ,KAAKK,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CACxBC,IADwB,CAClBC,SAAD,IAAe;AACnB,WAAO,OAAOA,UAAUC,IAAjB,KAA0B,WAA1B,IAAyCD,UAAUC,IAAV,CAAeA,IAAf,KAAwB,WAAxE;AACD,GAHwB,CAA3B;;AAKA,QAAMC,oBAAoB,4BAAaT,mBAAmBU,KAAnB,CAAyBA,KAAtC,EAA6CX,oBAA7C,EAAmEE,OAAnE,CAA1B;;AAEA,MAAIC,kBAAJ,EAAwB;AACtB,QAAI,iCAAgBA,mBAAmBQ,KAAnC,CAAJ,EAA+C;AAC7CR,yBAAmBQ,KAAnB,CAAyBA,KAAzB,IAAkC,MAAMD,iBAAxC;AACD,KAFD,MAEO,IAAI,0CAAyBP,mBAAmBQ,KAA5C,CAAJ,EAAwD;AAC7DR,yBAAmBQ,KAAnB,CAAyBC,UAAzB,GAAsC,qCACpCT,mBAAmBQ,KAAnB,CAAyBC,UADW,EAEpC,+BAAcF,iBAAd,CAFoC,CAAtC;AAID,KALM,MAKA;AACL,YAAM,IAAIG,KAAJ,CAAU,6BAAV,CAAN;AACD;;AAEDd,SAAKK,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCQ,MAApC,CAA2Cf,KAAKK,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCS,OAApC,CAA4Cd,kBAA5C,CAA3C,EAA4G,CAA5G;AACD,GAbD,MAaO;AACLA,uBAAmBQ,IAAnB,CAAwBA,IAAxB,GAA+B,WAA/B;AACAR,uBAAmBU,KAAnB,CAAyBA,KAAzB,GAAiCD,iBAAjC;AACD;AACF,C","file":"resolveStringLiteral.js","sourcesContent":["// @flow\n\nimport {\n  isJSXExpressionContainer,\n  isStringLiteral,\n  JSXAttribute,\n  stringLiteral\n} from 'babel-types';\nimport conditionalClassMerge from './conditionalClassMerge';\nimport getClassName from './getClassName';\nimport type {\n  StyleModuleImportMapType,\n  HandleMissingStyleNameOptionType\n} from './types';\n\ntype OptionsType = {|\n  handleMissingStyleName: HandleMissingStyleNameOptionType\n|};\n\n/**\n * Updates the className value of a JSX element using a provided styleName attribute.\n */\nexport default (path: *, styleModuleImportMap: StyleModuleImportMapType, styleNameAttribute: JSXAttribute, options: OptionsType): void => {\n  const classNameAttribute = path.node.openingElement.attributes\n    .find((attribute) => {\n      return typeof attribute.name !== 'undefined' && attribute.name.name === 'className';\n    });\n\n  const resolvedStyleName = getClassName(styleNameAttribute.value.value, styleModuleImportMap, options);\n\n  if (classNameAttribute) {\n    if (isStringLiteral(classNameAttribute.value)) {\n      classNameAttribute.value.value += ' ' + resolvedStyleName;\n    } else if (isJSXExpressionContainer(classNameAttribute.value)) {\n      classNameAttribute.value.expression = conditionalClassMerge(\n        classNameAttribute.value.expression,\n        stringLiteral(resolvedStyleName)\n      );\n    } else {\n      throw new Error('Unexpected attribute value.');\n    }\n\n    path.node.openingElement.attributes.splice(path.node.openingElement.attributes.indexOf(styleNameAttribute), 1);\n  } else {\n    styleNameAttribute.name.name = 'className';\n    styleNameAttribute.value.value = resolvedStyleName;\n  }\n};\n"]}